#!/usr/bin/python
## Copyright (c) 2013-2014 Quanta Research Cambridge, Inc.

## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use, copy,
## modify, merge, publish, distribute, sublicense, and/or sell copies
## of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:

## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.

## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
## BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
## ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.

import os, sys, shutil, string
import AST
import bsvgen
import xpsgen
import cppgen
import syntax
import argparse
import subprocess
import util
import re
import glob
import time
#import functools
#import math

AST.TypeDef.__bases__ += (cppgen.TypeDefMixin,)
AST.Function.__bases__ += (cppgen.NoCMixin,)
AST.Module.__bases__ += (cppgen.NoCMixin,)
AST.Method.__bases__ += (cppgen.MethodMixin,bsvgen.MethodMixin)
AST.StructMember.__bases__ += (cppgen.StructMemberMixin,)
AST.Struct.__bases__ += (cppgen.StructMixin,bsvgen.NullMixin)
AST.EnumElement.__bases__ += (cppgen.EnumElementMixin,)
AST.Enum.__bases__ += (cppgen.EnumMixin,bsvgen.EnumMixin)
AST.Type.__bases__ += (cppgen.TypeMixin,bsvgen.TypeMixin)
AST.Param.__bases__ += (cppgen.ParamMixin,bsvgen.ParamMixin)
AST.Interface.__bases__ += (cppgen.InterfaceMixin,bsvgen.InterfaceMixin)

supported_boards = ['ac701', 'zedboard', 'zc702', 'zc706', 'kc705', 'vc707', 'zynq100', 'v2000t', 'bluesim']
supported_os = ['android', 'ubuntu']

argparser = argparse.ArgumentParser("Generate C++/BSV/Xilinx stubs for an interface.")
argparser.add_argument('bsvfile', help='BSV files to parse', nargs='+')
argparser.add_argument('-B', '--board', default='zc702', choices=supported_boards,
                       help='Board to generate stubs and ucf constraints for')
argparser.add_argument('-O', '--OS', default=None, choices=supported_os,
                       help='Target operating system')
argparser.add_argument('-s2h', '--s2hinterface', help='BSV interface to generate stubs for software to hardware communication', action='append')
argparser.add_argument('-h2s', '--h2sinterface', help='BSV interface to generate stubs for hardware to software communication', action='append')
argparser.add_argument('-p', '--project-dir', default='./xpsproj', help='xps project directory')
argparser.add_argument('-e', '--edk-version', default=xpsgen.edkversion, help='Xilinx EDK version', choices=xpsgen.edkversions)
argparser.add_argument('-s', '--source', help='C++ source files', action='append')
argparser.add_argument(      '--contentid', help='Specify 64-bit contentid for PCIe designs')
argparser.add_argument('-I', '--cinclude', help='Specify C++ include directories', default=[], action='append')
argparser.add_argument('-V', '--verilog', default=[], help='Additional verilog sources', action='append')
argparser.add_argument('--xci', default=[], help='Additional IP sources', action='append')
argparser.add_argument('-C', '--constraint', help='Additional constraint files', action='append')
argparser.add_argument('-M', '--make', help='Run make on the specified targets', action='append')
argparser.add_argument('-x', '--export', help='Promote/export named interface from top module')
argparser.add_argument('-t', '--topbsv', help='Top-level bsv file')
argparser.add_argument('-D', '--bsvdefine', default=[], help='BSV define', action='append')
argparser.add_argument('-l', '--clib', default=[], help='C++ libary', action='append')
argparser.add_argument('-L', '--clibdir', default=[], help='C++ libary', action='append')
argparser.add_argument('-T', '--tcl', default=[], help='Vivado tcl script', action='append')
argparser.add_argument('-m', '--bsimsource', help='Bsim C++ source files', action='append')
argparser.add_argument('-b', '--bscflags', default=[], help='Options to pass to the BSV compiler', action='append')
argparser.add_argument('--xelabflags', default=[], help='Options to pass to the xelab compiler', action='append')
argparser.add_argument('--xsimflags', default=[], help='Options to pass to the xsim simulator', action='append')
argparser.add_argument('--ipdir', help='Directory in which to store generated IP')
argparser.add_argument('-q', '--qtused', help='Qt used in Bsim test application', action='store_true')
argparser.add_argument('--stl', help='STL implementation to use for Android builds', default=None)
argparser.add_argument('--floorplan', help='Floorplan XDC', default=None)
argparser.add_argument('-P', '--partition-module', default=[], help='Modules to separately synthesize/place/route', action='append')


tclReadVerilogTemplate='read_verilog [ glob %(verilog)s/*.v ]'
tclReadXciTemplate='''
generate_target {Synthesis} [get_files %(xci)s]
read_ip %(xci)s
'''

tclfileConstraintTemplate='''read_xdc {./constraints/%(xdcname)s}'''

tclboardTemplate='''
set partname {%(partname)s}
set boardname {%(boardname)s}
set xbsvdir {%(xbsvdir)s}
set xbsvipdir {%(ipdir)s}
set needspcie {%(needspcie)s}
%(tcldefines)s
'''

tclfileTemplate='''
# NOTE: typical usage would be "vivado -mode tcl -source create_mkPcieTop_batch.tcl" 
#
# STEP#0: define output directory area.
#
set outputDir ./hw
file mkdir $outputDir
#
# STEP#1: setup design sources and constraints
#
source board.tcl
source $xbsvdir/scripts/xilinx/tcl/log.tcl

####Report and DCP controls - values: 0-required min; 1-few extra; 2-all
set verbose      2
set dcpLevel     1

### logs
set runLog "run"
set commandLog "command"
set criticalLog "critical"
set logs [list $runLog $commandLog $criticalLog]
set rfh [open "$runLog.log" w]
set cfh [open "$commandLog.log" w]
set wfh [open "$criticalLog.log" w]

create_project -in_memory -part $partname
read_verilog [ glob {verilog/*.v} ]
%(read_verilog)s
%(read_xci)s
%(tclfileConstraints)s

source $xbsvdir/scripts/xbsv-synth-ip.tcl
if $needspcie {
    set pcieversion {3.0}
    set maxlinkwidth {X8}
    if {$boardname == {zc706}} {
        set maxlinkwidth {X4}
    }
    if {$boardname == {ac701}} {
        set maxlinkwidth {X4}
    }
    if {[version -short] == "2013.2"} {
        set pcieversion {2.1}
    }
    xbsv_synth_ip pcie_7x $pcieversion pcie_7x_0 [list \
                            CONFIG.mode_selection {Advanced} \
                            CONFIG.ASPM_Optionality {true} \
                            CONFIG.Buf_Opt_BMA {true} \
                            CONFIG.Bar0_64bit {true} \
                            CONFIG.Bar0_Size {16} \
                            CONFIG.Bar0_Scale {Kilobytes} \
                            CONFIG.Bar2_64bit {true} \
                            CONFIG.Bar2_Enabled {true} \
                            CONFIG.Bar2_Scale {Megabytes} \
                            CONFIG.Bar2_Size {1} \
                            CONFIG.Base_Class_Menu {Memory_controller} \
                            CONFIG.Device_ID {c100} \
                            CONFIG.IntX_Generation {false} \
                            CONFIG.MSI_Enabled {false} \
                            CONFIG.MSIx_Enabled {true} \
                            CONFIG.MSIx_PBA_Offset {1f0} \
                            CONFIG.MSIx_Table_Offset {200} \
                            CONFIG.MSIx_Table_Size {10} \
                            CONFIG.Maximum_Link_Width $maxlinkwidth \
                            CONFIG.Subsystem_ID {a705} \
                            CONFIG.Subsystem_Vendor_ID {1be7} \
                            CONFIG.Use_Class_Code_Lookup_Assistant {false} \
                            CONFIG.Vendor_ID {1be7} \
                           ]
# Description of MSIx_Table_Offset is in:
# Xilinx/Vivado/2013.2/data/ip/xilinx/pcie_7x_v2_1/xgui/pcie_7x_v2_1.tcl
# (it is byteoffset/8, expressed in hex)
}

if [file exists ../synth-ip.tcl] {
    source ../synth-ip.tcl
}

# STEP#2: run synthesis, report utilization and timing estimates, write checkpoint design
#
command "synth_design -name %(Dut)s -top %(Dut)s -part %(partname)s -flatten rebuilt" hw/synth_design.log

write_checkpoint -force $outputDir/top-post-synth > hw/temp.log
#not in 2013.2 report_timing_summary -warn_on_violation
#not in 2013.2 report_timing_summary -warn_on_violation -verbose  -file $outputDir/top-post-synth-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
report_io -file $outputDir/top-post-synth-io.rpt > hw/temp.log
puts "****************************************"
puts "If timing report says 'No timing paths found.' then the design met the timing constraints."
puts "If it reported negative slack, then the design did not meet the timing constraints."
puts "****************************************"
report_timing_summary -verbose  -file $outputDir/top-post-synth-timing-summary.rpt > hw/temp.log
report_timing -sort_by group -max_paths 100 -path_type summary -file $outputDir/top-post-synth-timing.rpt > hw/temp.log
report_utilization -verbose -file $outputDir/top-post-synth_utilization.txt > hw/temp.log
report_datasheet -file $outputDir/top-post-synth_datasheet.txt > hw/temp.log
write_verilog -force $outputDir/top-netlist.v > hw/temp.log
#report_power -file $outputDir/top-post-synth-power.rpt

#
# STEP#3: run placement and logic optimization, report utilization and timing estimates, write checkpoint design
#
%(sourceTcl)s
%(rewire_clock)s
command opt_design     hw/opt_design.log
# power_opt_design
command place_design    hw/place_design.log
report_timing_summary -file $outputDir/top-post-place-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
report_io -file $outputDir/top-post-place-io.rpt > hw/temp.log
write_checkpoint -force $outputDir/top-post-place > hw/temp.log
command phys_opt_design hw/phys_opt_design.log
report_timing_summary -file $outputDir/top-post-phys-opt-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
write_checkpoint -force $outputDir/top-post-phys-opt > hw/temp.log
#not in 2013.2 report_timing_summary -warn_on_violation -file $outputDir/top-post-place-timing-summary.rpt > hw/temp.log
#
# STEP#4: run router, report actual utilization and timing, write checkpoint design, run drc, write verilog and xdc out
#
command route_design hw/route_design.log
write_checkpoint -force $outputDir/top-post-route > hw/temp.log
#not in 2013.2 report_timing_summary -warn_on_violation
#not in 2013.2 report_timing_summary -warn_on_violation -file $outputDir/top-post-route-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
puts "****************************************"
puts "If timing report says 'No timing paths found.' then the design met the timing constraints."
puts "If it reported negative slack, then the design did not meet the timing constraints."
puts "****************************************"
report_timing_summary -file $outputDir/top-post-route-timing-summary.rpt > hw/temp.log
report_timing -sort_by group -max_paths 100 -path_type summary -file $outputDir/top-post-route-timing.rpt > hw/temp.log
report_clock_utilization -file $outputDir/top-clock_util.rpt > hw/temp.log
report_utilization -file $outputDir/top-post-route_util.rpt > hw/temp.log
report_datasheet -file $outputDir/top-post-route_datasheet.rpt > hw/temp.log
report_io -file $outputDir/top-post-route-io.rpt > hw/temp.log
#report_power -file $outputDir/top-post-route-power.rpt
#report_drc -file $outputDir/top-post-imp-drc.rpt
#write_verilog -force $outputDir/top-impl_netlist.v
write_xdc -no_fixed_only -force $outputDir/top-impl.xdc > hw/temp.log

## Halt the flow with an error if the timing constraints weren't met
## (thanks to http://xillybus.com/tutorials/vivado-timing-constraints-error for this way to do it)
set minireport [report_timing_summary -no_header -no_detailed_paths -return_string]
if {! [string match -nocase {*timing constraints are met*} $minireport]} {
#    send_msg_id showstopper-0 error "Timing constraints weren't met. Please check your design."
#    return -code error
   puts "Error: Timing constraints weren't met. Please check your design."
}

#
# STEP#5: generate a bitstream
# 
set_property SEVERITY {Warning} [get_drc_checks NSTD-1]
set_property SEVERITY {Warning} [get_drc_checks UCIO-1]
report_drc -file $outputDir/top-post-route-drc.rpt > hw/temp.log
write_bitstream -force -bin_file $outputDir/mkTop.bit

close $rfh
close $cfh
close $wfh
'''

tclzynqrewireclock = '''
foreach {pat} {CLK_GATE_hdmi_clock_if CLK_*deleteme_unused_clock* CLK_GATE_*deleteme_unused_clock* RST_N_*deleteme_unused_reset*} {
    foreach {net} [get_nets -quiet $pat] {
        puts "disconnecting net $net"
	disconnect_net -net $net -objects [get_pins -quiet -of_objects $net]
    }
}
'''

bitsmakeRuleTemplate='''
hw/mkTop.bit: $(vfile)
	vivado -mode batch -source vivado-impl.tcl $(VIVADOFLAGS)
	mkdir -p bin
	cp -f hw/*.rpt bin
'''

fpgamakeRuleTemplate='''
FPGAMAKE=$(XBSVDIR)/../fpgamake/fpgamake
fpgamake.mk: $(vfile) Makefile
	mkdir -p hw
	$(FPGAMAKE) -o fpgamake.mk %(partitions)s --floorplan=%(floorplan)s %(xdc)s -t $(MKTOP) -b hw/mkTop.bit verilog $(XBSVDIR)/verilog

hw/mkTop.bit: fpgamake.mk
	make -f fpgamake.mk
	mkdir -p bin
	cp -f Impl/*/*.rpt bin
'''

makefileTemplate='''
## make targets
##    all: make software and programmable logic binaries
##    run: run the program
##         pass parameters to software via 'make RUN_ARGS= run'
RUN_ARGS=

DTOP=%(project_dir)s
XBSVDIR=%(xbsvdir)s
BSVPATH = %(bsvpath)s
vfile=verilog/%(topbsvmod)s.v

BOARD=%(boardname)s
MKTOP=%(topbsvmod)s
OS=%(OS)s
ifeq ($(BOARD),bluesim)
    ALLTARGETS=bsim bsim_exe
else
  ifeq ($(OS),android)
    ALLTARGETS=android_exe%(debug)s bits
  else
    ALLTARGETS=ubuntu_exe bits
  endif
endif

BSCMAJOR=%(bscmajor)d
ifneq ($(BSCMAJOR), 2013)
    BSCWARNFLAGS += -demote-errors G0066:G0045 -suppress-warnings G0046
endif
BSCOPTFLAGS= -show-schedule -aggressive-conditions
BSCPATHFLAGS=  -bdir $(DTOP)/obj -vdir $(DTOP)/verilog -simdir $(DTOP)/obj -info-dir $(DTOP)/obj
BSCFLAGS = $(BSCWARNFLAGS) $(BSCOPTFLAGS) $(BSCPATHFLAGS) --wait-for-license -D TimeStamp=%(timestamp)s %(bscflags)s
BSIM_CXX = $(XBSVDIR)/cpp/BsimCtrl.cxx $(XBSVDIR)/cpp/TlpReplay.cxx $(XBSVDIR)/cpp/BsimDma.cxx $(XBSVDIR)/cpp/sock_utils.cxx %(bsimsource)s

VIVADOFLAGS= -notrace
XVLOGFLAGS =
XELABFLAGS = %(xelabflags)s
XSIMFLAGS  = %(xsimflags)s

%(mdefines)s

all: $(ALLTARGETS)

S2H = %(s2hinterface)s
H2S = %(h2sinterface)s
BSVFILES = %(bsvfiles)s
CPPFILES=%(sourcefiles)s $(addprefix %(project_dir)s/jni/, %(generatedCFiles)s)

timestampfile=sources/%(dut)s/.timestamp

$(timestampfile): %(bsvfiles)s
	cd $(DTOP); \
	$(XBSVDIR)/xbsvgen -B$(BOARD) -p %(project_dir)s -x $(MKTOP) \
	$(foreach s2h, $(S2H), -s2h $(s2h)) \
	$(foreach h2s, $(H2S), -h2s $(h2s)) \
	$(foreach f, $(CPPFILES), -s $f) \
        -t $(XBSVDIR)/bsv/$(TOP).bsv $(XBSVFLAGS) $(BSVFILES)
	touch $(timestampfile)

$(vfile): %(topbsvfile)s %(bsvfiles)s $(timestampefile)
	mkdir -p verilog/portal $(DTOP)/obj
	cd sources/%(dut)s; bsc %(bsvdefines)s $(BSCFLAGS) -remove-dollar -p +:$(DTOP)/generatedbsv:$(BSVPATH) -verilog -u -g %(topbsvmod)s %(topbsvfile)s
	sed -i 's|// On .*|// timestamp removed|' verilog/*.v
	for v in verilog/*.v; do $(XBSVDIR)/scripts/copy_verilog.py $$v $(subst :, ,$(BSVPATH)); done

bsim_exe:
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	cd jni; make -f Ubuntu.mk bsim_exe
	cp -v jni/bsim_exe bin

ubuntu_exe:
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	cd jni; make -f Ubuntu.mk
	cp -v jni/mk* bin

bsim: $(timestampfile)
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	mkdir -p $(DTOP)/obj
	cd sources; bsc -D BSIM %(bsvdefines)s $(BSCFLAGS) -p +:$(BSVPATH):%(dut)s/ -sim -u -g %(topbsvmod)s %(topbsvfile)s
	export BSC_CXXFLAGS="-I$(XBSVDIR)/cpp -I$(XBSVDIR) -DBSIM" ; cd sources; bsc $(BSCFLAGS) -p +:$(BSVPATH):%(dut)s/ -sim -e $(MKTOP) -o bsim $(DTOP)/obj/*.ba $(BSIM_CXX)
	cp -v sources/bsim* bin
	%(qtused)s

verilog: $(vfile)

lint: $(vfile)
	verilator --error-limit 200 --lint-only -Isources/%(dut)s -Isources/source $(vfile)

%(bitsmake)s

implementation: bits

program:
	fpgajtag bin/mkTop.bin.gz

reprogram:
	vivado -mode batch -source top-reprogram.tcl $(VIVADOFLAGS)
	xbsvutil reset /dev/fpga0

## for partial reconfiguration on VC707
verilog/portal/mkSynthesizeablePortalTop.v:
	mkdir -p verilog/portal
	mv -fv verilog/mkSynthesizeablePortalTop.v verilog/portal

## (*black_box*) causes vivado to ignore contents of the module and treat it as a black box
verilog/portalstub.v:
	make verilog/portal/mkSynthesizeablePortalTop.v
	cat verilog/portal/mkSynthesizeablePortalTop.v | sed 's/^module /(*black_box*)module /' > verilog/portalstub.v

hw/portaltop-post-synth.dcp: verilog/portal/mkSynthesizeablePortalTop.v $(vfile)
	make verilog/portalstub.v
	vivado -mode batch -source $(XBSVDIR)/scripts/portaltop-synth.tcl $(VIVADOFLAGS)

hw/mkpcietop-post-synth.dcp:
	make verilog/portalstub.v
	vivado -mode batch -source $(XBSVDIR)/scripts/mkpcietop-synth.tcl $(VIVADOFLAGS)

hw/mkPcieTop_pblock_portalTop_partial.bit: hw/mkpcietop-post-synth.dcp hw/portaltop-post-synth.dcp
	vivado -mode batch -source $(XBSVDIR)/scripts/mkpcietop-partial-reconfiguration.tcl $(VIVADOFLAGS)

partial: hw/mkPcieTop_pblock_portalTop_partial.bit

.PHONY: bits

ifeq ($(OS),android)

bits: hw/mkTop.bit
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	xxd hw/mkTop.bin | sed -e "s/  .*//" -e "s/ \(..\)\(..\) \(..\)\(..\)/ \\4\\3 \\2\\1/g" | xxd -r > bin/mkTop.xdevcfg.bin
	gzip -f bin/mkTop.xdevcfg.bin
	$(XBSVDIR)/scripts/check-timing.py bin/top-post-route-timing-summary.rpt

else

bits: hw/mkTop.bit
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	gzip -c hw/mkTop.bin > bin/mkTop.bin.gz
	$(XBSVDIR)/scripts/check-timing.py bin/top-post-route-timing-summary.rpt

endif

android_exe:
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	ndk-build
	cp -v libs/armeabi/android_exe bin

android_exe_debug:
	mkdir -p bin
	git rev-parse HEAD > bin/githash
	git diff | gzip -c > bin/gitdiff.patch.gz
	ndk-build -B V=1 NDK_DEBUG=1
	cp -v libs/armeabi/android_exe bin

ifeq ($(BOARD),bluesim)

ifeq ($(XBSV_DEBUG),1)
GDB=gdb
else
GDB=
endif

run:
	./bin/bsim& bsimpid=$$!; echo bsimpid $$bsimpid; $(GDB) ./bin/bsim_exe $(RUN_ARGS); retcode=$$?; kill $$bsimpid; exit $$retcode

else

    ifeq ($(OS),android)

run:
	$(XBSVDIR)/scripts/run.zedboard bin/mkTop.xdevcfg.bin.gz bin/android_exe $(RUN_ARGS)

    else

run: program
	timeout 3m catchsegv ./bin/mkpcietop $(RUN_ARGS)

    endif
endif

xsim: verilog
	xvlog $(XVLOGFLAGS) verilog/*.v
	xelab $(XELABFLAGS) work.$(MKTOP)

xsimrun: xsim
	xsim $(XSIMFLAGS) work.$(MKTOP)

JENKINS_HOST=sj9.qrclab.com
jenkins:
	$(XBSVDIR)/scripts/run.jenkins $(JENKINS_HOST) %(dut)s $(BOARD)

hwclean:
	rm -fr obj hw vivado*.jou vivado*.log fsm_encoding.os .Xil

clean: hwclean
	rm -fr verilog
'''

androidmk_template='''
include $(CLEAR_VARS)
LOCAL_ARM_MODE := arm
APP_SRC_FILES := $(addprefix %(project_dir)s/jni/,  %(generatedCFiles)s) %(source)s
PORTAL_SRC_FILES := $(addprefix %(xbsvdir)s/cpp/, portal.cpp poller.cpp sock_utils.cxx)
LOCAL_SRC_FILES := $(APP_SRC_FILES) $(PORTAL_SRC_FILES)

LOCAL_PATH :=
LOCAL_MODULE := android_exe
LOCAL_MODULE_TAGS := optional
LOCAL_LDLIBS := -llog %(clibdirs)s %(clibs)s
LOCAL_CPPFLAGS := "-march=armv7-a"
LOCAL_CFLAGS := -DZYNQ -DMMAP_HW -I%(xbsvdir)s -I%(xbsvdir)s/cpp -I%(xbsvdir)s/lib/cpp -I%(xbsvdir)s/drivers/zynqportal -I%(project_dir)s/jni %(cincludes)s %(cdefines)s -I%(xbsvdir)s/drivers/portalmem
LOCAL_CXXFLAGS := -DZYNQ -DMMAP_HW -I%(xbsvdir)s -I%(xbsvdir)s/cpp -I%(xbsvdir)s/lib/cpp -I%(xbsvdir)s/drivers/zynqportal -I%(project_dir)s/jni %(cincludes)s %(cdefines)s -I%(xbsvdir)s/drivers/portalmem

include $(BUILD_EXECUTABLE)
'''

linuxmakefile_template='''
CFLAGS_COMMON = -O -g -I%(project_dir)s/jni -I%(xbsvdir)s -I%(xbsvdir)s/cpp -I%(xbsvdir)s/lib/cpp %(sourceincludes)s %(cincludes)s %(cdefines)s -I%(xbsvdir)s/drivers/portalmem -I%(xbsvdir)s/drivers/pcieportal -I%(xbsvdir)s/drivers/zynqportal
CFLAGS = -DMMAP_HW $(CFLAGS_COMMON)

PORTAL_CPP_FILES = $(addprefix %(xbsvdir)s/cpp/, portal.cpp poller.cpp sock_utils.cxx)
SOURCES = $(addprefix %(project_dir)s/jni/,  %(generatedCFiles)s) %(source)s $(PORTAL_CPP_FILES)
LDLIBS := %(clibdirs)s %(clibs)s -pthread 

BSIM_EXE_CXX_FILES = BsimDma.cxx BsimCtrl.cxx TlpReplay.cxx
BSIM_EXE_CXX = $(addprefix %(xbsvdir)s/cpp/, $(BSIM_EXE_CXX_FILES))

test%(classname)s: $(SOURCES)
	g++ $(CFLAGS) -o %(classname)s $(SOURCES) $(LDLIBS)

bsim_exe: $(SOURCES)
	g++ $(CFLAGS_COMMON) -o bsim_exe -DBSIM $(SOURCES) $(BSIM_EXE_CXX) $(LDLIBS)
'''

def preprocess(source, defs):
    
    stack = [(True,True)]

    def pp(s):
        cond  = stack[-1][0]
        valid = stack[-1][1]
        i = re.search('\n`', s)
        if i == None:
            return s
        pre = s[:i.end()-1]
        s = s[i.end():]
        j = re.search('\s', s)
        tok = s[:j.start()]
        s = s[j.end():]
        if tok == 'ifdef':
            k = re.search('\s', s)
            sym = s[:k.start()]
            s = s[k.end():]
            new_cond = sym in defs
            new_valid = new_cond and valid
            stack.append((new_cond,new_valid))
        elif tok == 'ifndef':
            k = re.search('\s', s)
            sym = s[:k.start()]
            s = s[k.end():]
            new_cond = not sym in defs
            new_valid = valid and new_cond
            stack.append((new_cond,new_valid))
        elif tok == 'else':
            new_cond = not cond
            stack.pop()
            stack.append((new_cond,valid))
        elif tok == 'endif':
            stack.pop()
        elif tok == 'define':
            k = re.search('\n', s).start()
            foo = re.search('\s',s).start()
            sym = s[:min(k,foo)]
            defs.append(sym)
            s = s[k:]
        else:
            assert(False)
        prv = pre if valid and cond else '\n\n'
        return prv+pp('\n'+s)

    return pp(source)

if __name__=='__main__':
    exename = os.path.abspath(sys.argv[0])
    xbsvdir = os.path.dirname(exename)
    namespace = argparser.parse_args()

    if not namespace.export:
        sys.stderr.write('Must specify top level module name via -x/--export flag\n')
        sys.exit(-1)
    if not namespace.topbsv:
        sys.stderr.write('Must specify top BSV file via -t/--topbsv flag\n')
        sys.exit(-1)
    if not namespace.source:
        namespace.source = []
    if not namespace.bsimsource:
        namespace.bsimsource = []
    if not namespace.constraint:
        namespace.constraint = []
    if not namespace.verilog:
        namespace.verilog = []
    if not namespace.tcl:
        namespace.tcl = []
    if not namespace.xsimflags:
        namespace.xsimflags = ['-R']

    bscmajor = 0
    bscminor = 0
    popen = subprocess.Popen(['bsc', '-v'], stdout=subprocess.PIPE)
    m = re.match('.*version (\d+).(\d+)', popen.stdout.read())
    if m:
        bscmajor = int(m.group(1))
        bscminor = int(m.group(2))
        print "Using bsc %d.%d" % (bscmajor, bscminor)
    popen.terminate()

    project_dir = os.path.expanduser(namespace.project_dir)
    namespace.bsvdefine.append('project_dir=%s' % os.path.abspath(project_dir))
    srcdirs = []

    # remove intermediate files generated by parser generator
    # this is necessary due to silent failures when syntax.py is compiled
    os.path.exists('./parser.out')   and os.remove('./parser.out')
    os.path.exists('./parsetab.pyc') and os.remove('./parsetab.pyc')
    os.path.exists('./parsetab.py')  and os.remove('./parsetab.py')
    
    dutname = namespace.export
    boardname = namespace.board.lower()

    bsvdefines = namespace.bsvdefine
    if boardname == 'kc705':
        bsvdefines += ['Kintex7', 'PCIE']
    elif boardname == 'vc707':
        bsvdefines += ['Virtex7', 'PCIE']
    elif boardname == 'ac701':
        bsvdefines += ['Artix7',  'PCIE']
    elif boardname == 'v2000t':
        bsvdefines += ['Virtex7', 'PCIE']
    elif boardname == 'zedboard':
        bsvdefines += ['ZYNQ']
    elif boardname == 'zc702':
        bsvdefines += ['ZYNQ']
    bsvdefines += ['BOARD_'+boardname]
    if bscmajor < 2014:
        bsvdefines.append('ExportUnusedClocksAndResets')

    for inputfile in namespace.bsvfile:
        inputdir = os.path.dirname(inputfile)
        if not inputdir in srcdirs:
            srcdirs.append(inputdir)
        s0 = open(inputfile).read() + '\n'
        s1 = preprocess(s0, bsvdefines)
        s2 = syntax.parse(s1,inputfile)

    needs_pcie_7x_gen1x8 = False
    rewireclockstring = ''
    topmodulename = dutname
    if boardname == 'kc705':
        if not 'os' in namespace: namespace.os = 'ubuntu'
        partname = 'xc7k325tffg900-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'vc707':
        if not 'os' in namespace: namespace.os = 'ubuntu'
        partname = 'xc7vx485tffg1761-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'v2000t':
        if not 'os' in namespace: namespace.os = 'ubuntu'
        partname = 'xc7v2000tflg1925-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'ac701':
        if not 'os' in namespace: namespace.os = 'ubuntu'
        partname = 'xc7a200tfbg676-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'zc706':
        if not 'os' in namespace: namespace.os = 'android'
        partname = 'xc7z045ffg900-2'
        rewireclockstring = tclzynqrewireclock
        #namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', 'sources', 'processing_system7'))
        namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/zc7z045ffg900.xdc'))
    elif boardname == 'zynq100':
        if not 'os' in namespace: namespace.os = 'android'
        partname = 'xc7z100ffg900-2'
        rewireclockstring = tclzynqrewireclock
        #namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', 'sources', 'processing_system7'))
        namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/zc7z045ffg900.xdc'))
    else:
        if not 'os' in namespace: namespace.os = 'android'
        partname = 'xc7z020clg484-1'
        rewireclockstring = tclzynqrewireclock
        namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/zc7z020clg484.xdc'))
    namespace.verilog.append(os.path.join(xbsvdir, 'verilog'))

    namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/%s.xdc' % boardname))
    #if needs_pcie_7x_gen1x8:
        #subprocess.call(['make', '-C', xbsvdir, 'xilinx/pcie_7x_gen1x8'])
        #namespace.xci.append(os.path.join(xbsvdir, 'xilinx', 'pcie_7x_gen1x8', 'pcie_7x_0.xci'))

    ## code generation pass
    swProxies = []
    hwProxies = []
    swWrappers = []
    hwWrappers = []

    if not namespace.s2hinterface:
        namespace.s2hinterface = []
    if not namespace.h2sinterface:
        namespace.h2sinterface = []

    for i in set(namespace.s2hinterface + namespace.h2sinterface):
        ifc = syntax.globalvars[i]
        ifc = ifc.instantiate(dict(zip(ifc.params, ifc.params)))
        ifc.ind = AST.Interface(i, [], [], None, ifc.package)
        ifc.ind.insertPutFailedMethod()
        ifc.ind.req = ifc
        ifc.assignRequestResponseChannels()
        ifc.ind.assignRequestResponseChannels()
        if i in namespace.s2hinterface:
            swProxies.append(ifc)
            hwWrappers.append(ifc)
        if i in namespace.h2sinterface:
            hwProxies.append(ifc)
            swWrappers.append(ifc)

    def create_cpp_file(name):
        fname = os.path.join(project_dir, 'jni', name)
        f = util.createDirAndOpen(fname, 'w')
        print "Writing file ",fname
        f.write('#include "GeneratedTypes.h"\n');
        return f

    def create_bare_file(name):
        fname = os.path.join(project_dir, 'jni', name)
        f = util.createDirAndOpen(fname, 'w')
        print "Writing file ",fname
        return f

    generatedCFiles = []
    hname = os.path.join(project_dir, 'jni', 'GeneratedTypes.h')
    generated_hpp = util.createDirAndOpen(hname, 'w')
    generated_hpp.write('#ifndef __GENERATED_TYPES__\n');
    generated_hpp.write('#define __GENERATED_TYPES__\n');
    generated_hpp.write('#include "portal.h"\n')
    generated_hpp.write('#ifdef __cplusplus\n')
    generated_hpp.write('extern "C" {\n')
    generated_hpp.write('#endif\n')
    # global type declarations used by interface mthods
    for v in syntax.globaldecls:
        if (v.type == 'TypeDef'):
            v.emitCDeclaration(generated_hpp, 0, '')
    generated_hpp.write('\n');
    cppname = 'GeneratedCppCallbacks.cpp'
    generated_cpp = create_cpp_file(cppname)
    generatedCFiles.append(cppname)
    generated_cpp.write('\n#ifndef NO_CPP_PORTAL_CODE\n\n')

    for i in swProxies:
        cppname = '%sProxy.c' % i.name
        hppname = '%sProxy.h' % i.name
        hpp = create_cpp_file(hppname)
        cpp = create_cpp_file(cppname)
        hpp.write('#ifndef _%(name)s_H_\n#define _%(name)s_H_\n' % {'name': i.name.upper()})
        hpp.write('#include "%s.h"' % i.parentClass("portal"))
        i.emitCProxyDeclaration(hpp, generated_hpp, "Proxy")
        i.ind.emitCWrapperImplementation(cpp, generated_hpp, "Proxy", '', False)
        i.emitCProxyImplementation(cpp, generated_hpp, "Proxy", "", False)
        hpp.write('#endif // _%(name)s_H_\n' % {'name': i.name.upper()})
        hpp.close();
        cpp.close();
        generatedCFiles.append(cppname)

    for i in swWrappers:
        cppname = '%sWrapper.c' % i.name
        hppname = '%sWrapper.h' % i.name
        hpp = create_cpp_file(hppname)
        cpp = create_cpp_file(cppname)
        hpp.write('#ifndef _%(name)s_H_\n#define _%(name)s_H_\n' % {'name': i.name.upper()})
        i.ind.emitCProxyImplementation(cpp, generated_hpp, "WrapperStatus", "", False)
        i.emitCWrapperImplementation(cpp, generated_hpp, "Wrapper", '', False)
        generated_cpp.write('\n\n/************** Start of %sWrapper CPP ***********/\n' % i.name)
        generated_cpp.write('#include "%s"' % hppname)
        i.emitCWrapperDeclaration(hpp, generated_hpp, generated_cpp, "Wrapper")
        i.emitCWrapperImplementation(generated_cpp, generated_hpp, "Wrapper", '', True)
        hpp.write('#endif // _%(name)s_H_\n' % {'name': i.name.upper()})
        hpp.close();
        cpp.close();
        generatedCFiles.append(cppname)
    
    generated_cpp.write('\n#endif //NO_CPP_PORTAL_CODE\n')
    generated_cpp.close();
    generated_hpp.write('#ifdef __cplusplus\n')
    generated_hpp.write('}\n')
    generated_hpp.write('#endif\n')
    generated_hpp.write('#endif //__GENERATED_TYPES__\n');
    generated_hpp.close();

    def create_bsv_package(pname, files=[]):
        fname = os.path.join(project_dir, 'sources', dutname.lower(), '%s.bsv' % pname)
        bsv_file = util.createDirAndOpen(fname, 'w')
        bsv_file.write('package %s;\n' % pname)
        bsvgen.emitPreamble(bsv_file, files)
        print 'Writing file ', fname
        return bsv_file

    def close_bsv_package(bsv_file, pname):
        bsv_file.write('endpackage: %s\n' % pname)
        bsv_file.close()

    for i in hwWrappers:
        pname = '%sWrapper' % i.name
        bsv = create_bsv_package(pname, i.package)
        i.emitBsvWrapper(bsv)
        close_bsv_package(bsv,pname)
        
    for i in hwProxies:
        pname = '%sProxy' % i.name
        bsv = create_bsv_package(pname, i.package)
        i.emitBsvProxy(bsv, "Proxy")
        close_bsv_package(bsv,pname)

    tclboardname = os.path.join(project_dir, 'board.tcl')
    tclimplname = os.path.join(project_dir, 'vivado-impl.tcl')
    tclsynthname = os.path.join(project_dir, '%s-synth.tcl' % namespace.export.lower())
    makename = os.path.join(project_dir, 'Makefile')
    timestampname = os.path.join(project_dir, 'sources', dutname.lower(), '.timestamp')

    androidmkname = os.path.join(project_dir, 'jni', 'Android.mk')
    linuxmkname = os.path.join(project_dir, 'jni', 'Ubuntu.mk')
 
    if os != 'android':
        xpsgen.writeImpactCmd(dutname, os.path.join(project_dir, 'impact.cmd'))
        xpsgen.writeProgramTcl(dutname, os.path.join(project_dir, '%s-program.tcl' % dutname.lower()))
        xpsgen.writeReprogramTcl(dutname, os.path.join(project_dir, '%s-reprogram.tcl' % dutname.lower()))

    print 'Writing Android.mk', androidmkname
    print 'cinclude', namespace.cinclude
    print 'clib', namespace.clib
    print 'clibdir', namespace.clibdir
    className = cppgen.cName(dutname)
    substs = {
        #android
	'generatedCFiles': ' '.join(generatedCFiles),
	'project_dir': os.path.abspath(project_dir),
        #ubuntu
        'classname': className.lower(),
        'sourceincludes': ' '.join(['-I%s' % os.path.dirname(os.path.abspath(sf)) for sf in namespace.source]) if namespace.source else '',
        #common
        'source': ' '.join([os.path.abspath(sf) for sf in namespace.source]) if namespace.source else '',
        'xbsvdir': xbsvdir,
	'clibs': ' '.join(['-l%s' % l for l in namespace.clib]),
	'clibdirs': ' '.join([ '-L%s' % os.path.abspath(l) for l in namespace.clibdir ]),
	'cdefines': ' '.join([ '-D%s' % d for d in namespace.bsvdefine ]),
	'cincludes': ' '.join([ '-I%s' % os.path.abspath(i) for i in namespace.cinclude ])
    }
    f = util.createDirAndOpen(androidmkname, 'w')
    f.write(androidmk_template % substs)
    f.close()
    f = util.createDirAndOpen(linuxmkname, 'w')
    f.write(linuxmakefile_template % substs)
    f.close()
    if namespace.stl:
	    f = util.createDirAndOpen(os.path.join(project_dir, 'jni', 'Application.mk'), 'w')
	    f.write('APP_STL                 := %s\n' % namespace.stl)
	    f.close()

    print 'Writing tcl impl file', tclimplname
    tclsubsts = {'dut': topmodulename.lower(),
                 'Dut': topmodulename,
                 'rewire_clock': rewireclockstring,
                 'sourceTcl': ''.join(['source {%s}\n' % os.path.basename(tcl) for tcl in namespace.tcl]),
                 'project_dir': project_dir,
                 'partname': partname,
                 'boardname': boardname,
                 'xbsvdir': xbsvdir,
                 'tclfileConstraints': '\n'.join([tclfileConstraintTemplate
                                                  % { 'xdcname': os.path.basename(f) }
                                                  for f in namespace.constraint ]),
                 'read_verilog': '\n'.join([tclReadVerilogTemplate
                                            % { 'verilog': f } for f in namespace.verilog]),
                 'read_xci': '\n'.join([tclReadXciTemplate
                                        % { 'xci': f } for f in namespace.xci]),
                 'needspcie': 1 if needs_pcie_7x_gen1x8 else 0,
                 'tcldefines': '\n'.join(['set %s {%s}' % (var,val) for (var,val) in map(util.splitBinding, namespace.bsvdefine)]),
                 'ipdir': os.path.abspath(namespace.ipdir) if namespace.ipdir else xbsvdir
                 }
    tcl = util.createDirAndOpen(tclimplname, 'w')
    tcl.write(tclfileTemplate % tclsubsts)
    tcl.close()
    tcl = util.createDirAndOpen(tclboardname, 'w')
    tcl.write(tclboardTemplate % tclsubsts)
    tcl.close()

    if namespace.verilog:
        for verilog in namespace.verilog:
            print 'Copying verilog sources from', verilog
            dstverilog = os.path.join(project_dir, 'sources', os.path.basename(verilog))
            ## this path is here so we can overwrite sources
            if os.path.exists(dstverilog):
                for f in glob.glob(os.path.join(verilog, '*')):
                    print f, os.path.basename(f)
                    dstpath = os.path.join(project_dir, 'sources', os.path.basename(verilog), os.path.basename(f))
                    if os.path.isfile(f):
                        shutil.copyfile(f, dstpath)
                    else:
                        shutil.copytree(f, dstpath)
            else:
                shutil.copytree(verilog, os.path.join(project_dir, 'sources', os.path.basename(verilog)))
    if namespace.constraint:
        for constraint in namespace.constraint:
            print 'Copying constraint file from', constraint
            dstconstraintdir = os.path.join(project_dir, 'constraints')
            if not os.path.exists(dstconstraintdir):
                os.makedirs(dstconstraintdir)
            ## this path is here so we can overwrite sources
            shutil.copy(constraint, dstconstraintdir)
    if namespace.tcl:
        for tcl in namespace.tcl:
            print 'Copying tcl file from', tcl
            ## this path is here so we can overwrite sources
            shutil.copy(tcl, project_dir)

    print 'Writing Makefile', makename
    make = util.createDirAndOpen(makename, 'w')
    debug_flag = ''
    if os.environ.has_key('XBSV_DEBUG'):
        debug_flag = '_debug'

    if namespace.floorplan and namespace.partition_module:
        bitsmake=fpgamakeRuleTemplate % {'partitions': ' '.join(['-s %s' % p for p in namespace.partition_module]),
					 'floorplan': os.path.abspath(namespace.floorplan),
					 'xdc': ' '.join(['--xdc=%s' % os.path.abspath(xdc) for xdc in namespace.constraint])
					 }
    else:
        bitsmake=bitsmakeRuleTemplate

    make.write(makefileTemplate % {'xbsvdir': xbsvdir,
                                   'bsvpath': ':'.join(list(set([os.path.dirname(os.path.abspath(bsvfile)) for bsvfile in namespace.bsvfile]
                                                                + [os.path.join(xbsvdir, 'bsv')]
                                                                + [os.path.join(xbsvdir, 'lib/bsv')]
                                                                + [os.path.join(xbsvdir, 'generated/xilinx')]))),
                                   'bsvdefines': util.foldl((lambda e,a: e+' -D '+a), '', bsvdefines),
                                   'boardname': boardname,
                                   'OS': namespace.os,
                                   'debug': debug_flag,
                                   'qtused': 'cd jni; qmake ../..; make' if namespace.qtused else '',
                                   's2hinterface': ' '.join(namespace.s2hinterface),
                                   'h2sinterface': ' '.join(namespace.h2sinterface),
                                   'bsvfiles': ' '.join([ os.path.abspath(bsvfile) for bsvfile in namespace.bsvfile]),
                                   'sourcefiles': ' '.join([os.path.abspath(source) for source in namespace.source]) if namespace.source else '',
                                   'bsimsource': ' '.join([os.path.abspath(bsimsource) for bsimsource in namespace.bsimsource]) if namespace.bsimsource else '',
                                   'generatedCFiles': ' '.join(generatedCFiles),
                                   'includepath': ' '.join(['-I%s' % os.path.dirname(os.path.abspath(source)) for source in namespace.source]) if namespace.source else '',
                                   'project_dir': os.path.abspath(project_dir),
                                   'topbsvfile' : os.path.abspath(namespace.topbsv),
                                   'topbsvmod'  : namespace.export,
                                   'dut' : namespace.export.lower(),
                                   'Dut': topmodulename,
                                   'timestamp' : int(time.time()),
                                   'clibs': ' '.join(['-l%s' % l for l in namespace.clib]),
                                   'cdefines': ' '.join([ '-D%s' % d for d in namespace.bsvdefine ]),
                                   'mdefines': '\n'.join(['%s="%s"' % (var,val) for (var,val) in map(util.splitBinding, namespace.bsvdefine)]),
                                   'bscmajor': bscmajor,
                                   'bscminor': bscminor,
                                   'bscflags': ' '.join(namespace.bscflags),
                                   'xelabflags': ' '.join(namespace.xelabflags),
                                   'xsimflags': ' '.join(namespace.xsimflags),
				   'bitsmake': bitsmake
                                   })
    make.close()
    print namespace.xsimflags
    timestamp = util.createDirAndOpen(timestampname, 'w')
    timestamp.close()

    print '############################################################'
    print '## To build:'
    print '    cd %s; make all' % (project_dir)
    print '## To run:'
    print '    cd %s; make run' % (project_dir)
    print '## You can use XPS to generate bit file or exit and let make complete the process.'

    if namespace.make:
        os.chdir(project_dir)
        os.putenv('PWD', subprocess.check_output(['pwd'])[0:-1])
        subprocess.call(['make'] + namespace.make)
